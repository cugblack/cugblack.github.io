---
layout:     post
title:      容器镜像构建最佳实践-dockerfile优化
subtitle:   dockerfile优化与镜像最佳实践
date:       2019-04-11
author:     cugblack
header-img: img/post-bg-digital-native.jpg
catalog: true
tags:
    - docker
    - dockerfile
    - 镜像构建
    - image
    
---

> 镜像是容器中非常重要的一份子，它是运行中容器的文件系统，一个镜像的质量将直接影响我们在容器中运行的服务的质量，因此，我们画一点时间研究并优化了镜像的制作-dockerfile



在使用docker容器的过程中，你可能会遇到一下问题：

> * 容器镜像太大，构建缓慢
> * 容器启动时遇到某些奇怪的报错
> * 镜像中添加了你不需要的东西
> * 重复构建效率低下

当然，你可能还会遇到其他的一些问题，我们不一一列举，接下来我会介绍一些在构建镜像时需要注意到的东西，可以避免你走一些弯路。

![docker-logo](https://github.com/cugblack/cugblack.github.io/blob/master/img/docker.png)



------

## 你需要知道镜像的构建流程

在构建docker镜像时，会经历几个过程：

 1. 首先我们执行命令发起镜像构建：`docker build -t repo/image_name:tag .`
 2. docker守护进程载入dockerfile，并将构建上下文拉入构建空间
 3. 解析dockerfile构建的参数，如 FROM、RUN等
 4. 根据解析出来的命令执行对应的操作
 5. 给镜像添加标签

> *这样来看，我们就能发现，在构建过程中还是有很多可以优化步骤与细节，来让我们更快更好的构建镜像。*
 
 
## 优化镜像构建过程




### 1. 使用.dockerignore

在构建镜像前，请确保你的构建目录是干净的，或者使用`.dockerignore`文件，构建过程中不需要的文件过滤掉，避免在构建开始时浪费太多的时间将目录内的文件加载到构建上下文。

---

### 2. 使用合适的基础镜像

在我们使用dockerfile的时候，一个合适的基础镜像会让我们事半功倍，通常情况下，如果你非常清楚你的运行环境的依赖的话，推荐你使用[alpine](https://hub.docker.com/_/alpine)，最小的linux镜像，专为容器而生，当然，它的底层包安装的并不全，所以如果你不是特别了解自己项目的底层依赖的话，建议你选择一些其他的镜像，如`ubuntu、debian`等，这些镜像会比`alpine`稍大，但是底层的依赖更全面。

同时，你应该注意到，如果你的多个镜像都需要某类相同的依赖，比如安装相同的软件依赖等等，这时你应该考虑为这些镜像制作一个统一的基础镜像，避免每次构建都执行相同的操作，消耗大量的时间去等待构建。

---

### 3. 删除构建中的缓存

在镜像构建时我们可能会安装一些软件，在安装后将缓存文件清掉，这有助于减小你镜像的体积。比如使用`apt-get`安装完软件后，清除 `/var/lib/apt`目录，在alpine系统下安装时，尽可能使用`apk add --no-cache`参数等等，再着就是删除那些安装时下载的压缩文件等。


---

### 4. 合理排序你的dockerfile文件

这部分有两个问题要考虑：
> * dockerfile的可读性
> * 层次间的缓存使用

为了让别人能够看懂你的dockerfile，请不要把所有的需要执行`RUN`命令都放到一起。虽然这样可能你会使用比较少的层次，但是可读性非常差，如果其中的某一部出现了问题也非常难排查。我们提倡你尽可能把同一类的问题放在相邻的层次解决，以便更加清晰的来查看dockerfile的步骤。

此外，由于在构建的时候，一层一层的构建，所以在构建时，我们应该合理的安排构建的顺序，比如某些经常变化的层次，尽可能的放在下层，而经常变化的内容应放在上层。

---

### 5. 尽可能的减少层数

当然我们应该尽可能的使用比较少的层数，当然了，这有个前提，在保证可读性的情况下。也就是说，你可以把同一类操作尽可能的放在一起，比如安装某个依赖时，写成这样：
```
RUN apt-get update \
    && apt-get install -y curl vim
```
而不是：
```
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y vim
```
---

### 6. 多阶段部署

在docker-17.05版本引入了多阶段部署的概念，允许在dockerfile中使用多个`FROM`，并以你最后一个`FROM`为准，这对于我们构建镜像有什么意义呢？这意味着如果你的镜像有多重文件依赖，但你并不想把编译时的所有工具都打包到你的镜像中，这个时候我们可以将dockerfile分为两步，先安装依赖的编译工具以及对源码进行编译，在第二个`FROM`中，从第一个镜像中拷贝构建好的包即可，下面是一个例子，以构建go环境为例：
```
#编译：
FROM golang：1.10.3 as builder
COPY server.go /build/
WORKDIR /build
RUN CGO_ENABLED=0 GOOS=linux GOARCH=arm64 GOARM=6 go build -ldflags '-w -s' -o server
#运行
FROM scratch
COPY --from=builder /build/server /
ENTRYPOINT ["/server"]
```

---

### 7. 遵循每个容器只做一件事

在一个镜像内，最好只包含一个服务，将应用解藕，模块化，虽然最开始可能会比较麻烦，但是之后的维护、升级等都会很方便，影响范围也会比较小。同时也可以减小单个镜像的体积，加快构建与拉取速度。

---

### 8. 不要在dockerfile中单独修改文件的权限

dockerfile构建时，上层文件都是自下层拷贝而来，这意味着，如果你是用单独的一层修改文件的权限，它会先把底层的文件拷贝一份上来，并对这份文件进行修改，所以这意味着你要存储两份这个文件，镜像体积也会变大。好的解决办法是，使用启动脚本或在`ENTRYPOINT`的脚本内修改，或者在拷贝文件的时候修改。

---

### 9. 使用合适的tags

在构建镜像时使用合适的tags，这有利于你的版本迭代以及服务的滚动或回滚，我们的经验是使用代码的commitID作为镜像的tags，简单直观的显示的代码的版本，并保证了不会重复。
